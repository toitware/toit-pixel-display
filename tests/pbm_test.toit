// Copyright (C) 2020 Toitware ApS. All rights reserved.
// Use of this source code is governed by an MIT-style license that can be
// found in the LICENSE file.

import expect show *
import pixel_display.two_color
import pixel_display.gray_scale
import pixel_display.texture show Transform PbmParser_

toit_logo := #[
  'P', '4', '\n', '6', '2', ' ', '4', '0', '\n',
  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38,
  0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfc,
  0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfc,
  0x1f, 0xff, 0x00, 0x00, 0x00, 0x03, 0xff, 0xe0,
  0x01, 0xff, 0xf8, 0x00, 0x00, 0x7f, 0xfe, 0x00,
  0x00, 0x0f, 0xff, 0xc0, 0x0f, 0xff, 0xc0, 0x00,
  0x00, 0x01, 0xff, 0xfc, 0xff, 0xfe, 0x00, 0x00,
  0x00, 0x00, 0x0f, 0xff, 0xff, 0xc0, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xff, 0xfc, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x3c, 0xf0, 0x00, 0x00, 0x00,
  0x40, 0x00, 0x00, 0x38, 0x70, 0x00, 0x00, 0x08,
  0xe0, 0x00, 0x00, 0x78, 0x78, 0x00, 0x00, 0x1c,
  0xf0, 0x00, 0x00, 0xf0, 0x3c, 0x00, 0x00, 0x3c,
  0x78, 0x00, 0x00, 0xe0, 0x1c, 0x00, 0x00, 0x78,
  0x3c, 0x00, 0x01, 0xe0, 0x1e, 0x00, 0x00, 0xf0,
  0x1e, 0x00, 0x03, 0xc0, 0x0f, 0x00, 0x01, 0xe0,
  0x0f, 0x00, 0x03, 0xc0, 0x0f, 0x00, 0x03, 0xc0,
  0x07, 0x00, 0x07, 0x80, 0x07, 0x80, 0x03, 0x80,
  0x07, 0x80, 0x07, 0x00, 0x03, 0x80, 0x07, 0x80,
  0x03, 0xc0, 0x0f, 0x00, 0x03, 0xc0, 0x0f, 0x00,
  0x01, 0xe0, 0x1e, 0x00, 0x01, 0xe0, 0x1e, 0x00,
  0x00, 0xf0, 0x3c, 0x00, 0x00, 0xf0, 0x3c, 0x00,
  0x00, 0x7c, 0x7c, 0x00, 0x00, 0xf8, 0xf8, 0x00,
  0x00, 0x3f, 0xf8, 0x00, 0x00, 0x7f, 0xf0, 0x00,
  0x00, 0x1f, 0xf0, 0x00, 0x00, 0x3f, 0xe0, 0x00,
  0x00, 0x07, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00
  ]

main:
  test_parse_magic_number
  test_parse_whitespace
  test_parse_multiple_whitespace
  test_parse_toit_logo
  test_draw_on_pbm

test_parse_magic_number:
  incorrect_magic_number := ByteArray 2: ['O','4'][it]
  expect_throw "INVALID PBM": (PbmParser_ incorrect_magic_number).parse_magic_number_

  incorrect_magic_number = ByteArray 2: ['P','3'][it]
  expect_throw "INVALID PBM": (PbmParser_ incorrect_magic_number).parse_magic_number_

  correct_magic_number := ByteArray 2: ['P','4'][it]
  parser := PbmParser_ correct_magic_number
  expect_no_throw: parser.parse_magic_number_
  expect_equals 2 parser.next_

test_parse_whitespace char:
  expect_no_throw:
    parser := PbmParser_ (ByteArray 1: char)
    parser.parse_whitespace_

test_parse_whitespace:
  test_parse_whitespace '\t'
  test_parse_whitespace '\v'
  test_parse_whitespace ' '
  test_parse_whitespace '\n'
  test_parse_whitespace '\r'
  test_parse_whitespace '\f'
  expect_throw "INVALID PBM": (PbmParser_ (ByteArray 1: 'A')).parse_whitespace_

test_parse_multiple_whitespace:
  parser := PbmParser_ (ByteArray 6: ['\t', '\v', ' ', '\n', '\r', '\f'][it])
  expect_no_throw: parser.parse_multiple_whitespace_
  expect_equals 6 parser.next_

  parser = PbmParser_ (ByteArray 6: ['\t', '\v', ' ', '\n', '\r', '\f'][it])
  expect_no_throw: parser.parse_multiple_whitespace_ --at_least_one
  expect_equals 6 parser.next_

  parser = PbmParser_ (ByteArray 1: ['\t'][it])
  expect_no_throw: parser.parse_multiple_whitespace_ --at_least_one
  expect_equals 1 parser.next_

  parser = PbmParser_ (ByteArray 7: ['\t', '\v', ' ', 'A', '\n', '\r', '\f'][it])
  expect_no_throw: parser.parse_multiple_whitespace_
  expect_equals 3 parser.next_

  parser = PbmParser_ (ByteArray 6: ['A', '\v', ' ', '\n', '\r', '\f'][it])
  expect_no_throw: parser.parse_multiple_whitespace_
  expect_equals 0 parser.next_

  parser = PbmParser_ (ByteArray 6: ['A', '\v', ' ', '\n', '\r', '\f'][it])
  expect_throw "INVALID PBM": parser.parse_multiple_whitespace_ --at_least_one

test_parse_number:
  parser := PbmParser_ (ByteArray 2: ['1', ' '][it])
  number := parser.parse_number_
  expect_equals 1 number

  parser = PbmParser_ (ByteArray 3: ['1', '2', ' '][it])
  number = parser.parse_number_
  expect_equals 12 number

  parser = PbmParser_ (ByteArray 3: ['1', 'A', ' '][it])
  expect_throw "INVALID PBM": number = parser.parse_number_

  parser = PbmParser_ (ByteArray 2: ['1', '2'][it])
  expect_throw "INVALID PBM": number = parser.parse_number_

test_parse_toit_logo:
  logo_width ::= 62
  logo_height ::= 40
  pbm := two_color.Pbm.parse toit_logo
  expect_equals logo_width pbm.width
  expect_equals logo_height pbm.height
  expect_bytes_equal
    pbm.row 0
    ByteArray 8: [0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38][it]
  expect_bytes_equal
    pbm.row logo_height - 1
    ByteArray 8: [0x00, 0x07, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00][it]

test_draw_on_pbm:
  texture := two_color.PbmTexture 0 0 Transform.identity 1 toit_logo
  texture.set_all_pixels

  // It still parses with all pixels overwritten.
  texture2 := two_color.PbmTexture 0 0 Transform.identity 1 toit_logo

  toit_logo[10..].do:
    expect_equals 0xff it

  texture.h.repeat:
    texture.clear_pixel 0 it

  toit_logo[10..].do:
    expect
      it == 0xff or it == 0x7f

  expect_throw "OUT_OF_RANGE": texture.clear_pixel -1 5
  expect_throw "OUT_OF_RANGE": texture.clear_pixel 5 -1
  expect_throw "OUT_OF_RANGE": texture.set_pixel 62 5
  expect_throw "OUT_OF_RANGE": texture.set_pixel 5 40

  // We set all pixels including the ones that were on the right hand side and
  // were only there because the backing was rounded up to the next multiple of
  // 8.
  texture.set_all_pixels

  // Clear all the visible pixels in the 62x40 area.
  62.repeat: | x |
    40.repeat: | y |
      texture.clear_pixel x y

  canvas := two_color.Canvas 128 128

  // Draw on a two color canvas.
  texture.write 0 0 canvas

  // Check that the rounded up pixels off the edge of the PBM are not drawn.
  canvas.pixels_.do: expect_equals 0 it

  // The same for a byte-oriented texture.
  texture_gray := gray_scale.PbmTexture 0 0 Transform.identity 255 toit_logo
  canvas_gray := gray_scale.Canvas 128 128
  texture_gray.write 0 0 canvas_gray
  canvas_gray.pixels_.do: expect_equals 0 it
